#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# ---------------------------------------------------------------------------
# game-of-life
# ---------------------------------------------------------------------------
# Author: Videonauth <videonauth@googlemail.com>
# License: MIT (see LICENSE file)
# Date: 06.01.22 - 13:40
# Purpose: Using pygame library to create a version of conways game of life
# Written for: Python 3.9.5
# ---------------------------------------------------------------------------
"""
Task:
Create Conways game of life with help of pygame library.

Rules:
The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is
in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts
with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent.
At each step in time, the following transitions occur:

1. Any live cell with fewer than two live neighbours dies, as if by underpopulation.
2. Any live cell with two or three live neighbours lives on to the next generation.
3. Any live cell with more than three live neighbours dies, as if by overpopulation.
4. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

These rules, which compare the behavior of the automaton to real life, can be condensed into the following:

1. Any live cell with two or three live neighbours survives.
2. Any dead cell with three live neighbours becomes a live cell.
3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.

The initial pattern constitutes the seed of the system. The first generation is created by applying the above rules
simultaneously to every cell in the seed, live or dead; births and deaths occur simultaneously, and the
discrete moment at which this happens is sometimes called a tick. Each generation is a pure function of
the preceding one. The rules continue to be applied repeatedly to create further generations.

Goals:
- have logging
- have an initial set state, by user choice.
- have a proper game loop with error checking and error states.
- have an option for the game to be run for x amount of frames until it ends, or have it run until user interrupt.
- have an FPS limiter.
- have a resizable window.
- have an option to choose the playing field size
- have full screen swap option
- have mouse and keyboard input

Resources:
python 3.9 documentation: https://docs.python.org/3.9/
pygame documentation: https://www.pygame.org/docs/
"""
import time
from typing import List

import pygame


def generate_playingfield(_playfield_height: int, _playfield_width: int) -> List[List[int]]:
    """
    Create a matrix from lists, with the specified height and width.

    int _playfield_width : matrix size in x direction
    int _playfield_height : matrix size in y direction
    return : list[list[], ...] as a matrix
    """
    if _playfield_height <= 0 or _playfield_width <= 0:
        raise ValueError("Height and width must be positive")

    if _playfield_height == 1 and _playfield_width == 1:
        raise ValueError("At least one dimension must be greater than one")

    return [[0 for _ in range(_playfield_width)] for __ in range(_playfield_height)]


class Colour:
    black = (0, 0, 0)
    white = (255, 255, 255)
    red = (255, 0, 0)
    green = (0, 255, 0)
    blue = (0, 0, 255)


def main():
    # init pygame
    pygame.init()

    # limits frames per second
    frame_limit = 1/60

    # create window
    window_size = width, height = 1280, 840
    window = pygame.display.set_mode(window_size)

    # setup surface
    # surface = pygame.Surface(window_size)
    playfield_surface = pygame.Surface((height, height))

    # setup font
    font = pygame.font.SysFont(None, 20)

    # setup colours
    colour = Colour()

    # setup playfield to with and height given
    playfield_width = 20
    playfield_height = 20
    playfield = generate_playingfield(playfield_height, playfield_width)

    # flush output
    window.fill(colour.black)
    playfield_surface.fill(colour.black)
    pygame.display.flip()

    # setting up game loop
    _last_frame_time = 0
    _running = True
    cell_size = height // max(playfield_width, playfield_height)
    mouse_x = 0
    mouse_y = 0
    button = 0
    _locked = False
    _pressed = False
    while _running:
        _t = time.time()

        # event handling for input
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                _running = False
                continue
            if event.type == pygame.MOUSEBUTTONDOWN and not _pressed:
                mouse_x, mouse_y = event.pos
                button = event.button
                _pressed = True
                # print(f'Button: {button} Position: {mouse_x} x {mouse_y}')
            elif event.type == pygame.MOUSEBUTTONUP:
                _locked = False
                _pressed = False

        # flush window and surface
        window.fill(colour.black)
        playfield_surface.fill(colour.black)

        # TODO: create menu UI being drawn switching the different program states

        if _pressed and not _locked and button == 1:
            if mouse_x < (playfield_width * cell_size) and mouse_y < (playfield_height * cell_size):
                cell_x = mouse_x // cell_size
                cell_y = mouse_y // cell_size
                if playfield[cell_y][cell_x] == 0:
                    playfield[cell_y][cell_x] = 1
                elif playfield[cell_y][cell_x] == 1:
                    playfield[cell_y][cell_x] = 0
                _locked = True

        # TODO: create simulation
        # TODO: create options UI

        # drawing playfield
        start_x = 0
        start_y = 0
        for line in playfield:
            for cell in line:
                if cell == 0:
                    pygame.draw.rect(playfield_surface, colour.white, (start_x, start_y, cell_size, cell_size), 1)
                elif cell == 1:
                    pygame.draw.rect(playfield_surface, colour.blue, (start_x, start_y, cell_size, cell_size))
                    pygame.draw.rect(playfield_surface, colour.white, (start_x, start_y, cell_size, cell_size), 1)
                else:
                    pass
                start_x += cell_size
            start_x = 0
            start_y += cell_size

        window.blit(playfield_surface, (0, 0))

        # output fps
        if _last_frame_time != 0:
            text = font.render(f'FPS: {1 / _last_frame_time}', True, colour.white)
            window.blit(text, (height + 20, 20))

        # wait when to fast
        while time.time() - _t < frame_limit:
            pass

        # calculate frame time
        _t_stop = time.time()
        _last_frame_time = _t_stop - _t

        # flip screen buffer
        pygame.display.flip()

#         # skip frames if needed
#         if last_frame_time > 1/fps_limit:
#             last_frame_time = time.time() - _frame_start_t
#             continue


if __name__ == '__main__':
    main()
